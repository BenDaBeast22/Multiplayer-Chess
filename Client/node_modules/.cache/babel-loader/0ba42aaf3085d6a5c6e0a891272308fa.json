{"ast":null,"code":"import { arrayEquals } from './Helpers';\nimport { King, Rook, Piece } from './Pieces';\nconst BLACK = false;\nconst WHITE = true;\n\nclass ChessGame {\n  constructor() {\n    this.turn = WHITE;\n  }\n\n  isLegalMove(legalMoves, endPos) {\n    // Check that move is legal\n    for (let move of legalMoves) {\n      if (arrayEquals(move, endPos)) {\n        return true;\n      }\n    }\n  }\n\n  checkedOpponent(board, turn, oppKingPos) {\n    const squaresCovered = this.squaresCovered(board, turn);\n\n    for (let sqr of squaresCovered) {\n      if (arrayEquals(sqr, oppKingPos)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  squaresCovered(board, turn) {\n    let squaresCovered = [];\n\n    for (let r = 0; r < 8; r++) {\n      for (let c = 0; c < 8; c++) {\n        if (board[r][c] instanceof Piece) {\n          const piece = board[r][c];\n\n          if (turn === piece.type) {\n            piece.legalMoves(board, [r, c], piece).forEach(m => squaresCovered.push(m));\n          }\n        }\n      }\n    }\n\n    return squaresCovered;\n  }\n\n  isCheckmate(board, startPos, piece, kingOppPos) {\n    // Check every move you can to see if opponent can get out of check\n    for (let r = 0; r < 8; r++) {\n      for (let c = 0; c < 8; c++) {\n        const oppStartPos = board[r][c];\n\n        if (oppStartPos instanceof Piece && oppStartPos.type !== piece.type) {\n          const lMoves = oppStartPos.legalMoves(board, [r, c], piece);\n          console.log(\"Piece lmoves\");\n          console.log(`r = ${r}, c = ${c}`);\n          console.log(oppStartPos.imgName);\n          console.log(lMoves);\n\n          for (let move of lMoves) {\n            const [x, y] = move;\n            let originalPos = board[r][c];\n            let moveSquare = board[x][y];\n            board[r][c] = \"-\";\n            board[x][y] = piece;\n            const squaresCovered = this.squaresCovered(board, piece.type);\n\n            if (!squaresCovered.some(s => arrayEquals(s, kingOppPos))) {\n              board[r][c] = originalPos;\n              board[x][y] = moveSquare;\n              console.log(\"squaresCovered\");\n              console.log(squaresCovered);\n              console.log(\"kingOppPos\");\n              console.log(kingOppPos);\n              return false;\n            }\n\n            board[x][y] = moveSquare;\n            board[r][c] = originalPos;\n          }\n        }\n      }\n    }\n\n    return true; // for (let move of oppSquaresCovered) {\n    //   const [x, y] = move;\n    //   board[a][b] = \"-\";\n    //   const moveSquare = board[x][y]; \n    //   board[x][y] = piece;\n    //   // If opponent can escape check with their move checkmate is false \n    //   if (!squaresCovered.some(s => arrayEquals(s, kingOppPos))) {\n    //     return false;\n    //   }\n    //   board[x][y] = moveSquare;\n    // }\n    // // If opponent can't escape it's CHECKMATE!\n    // return true;\n  }\n\n  kingUnderAttack(board, startPos, endPos, piece, kingPos) {\n    if (piece instanceof King) kingPos = endPos;\n    const [a, b] = startPos;\n    const [x, y] = endPos; // const newBoard = board.map(o => o);\n\n    const endPiece = board[x][y];\n    board[a][b] = \"-\";\n    board[x][y] = piece; // Check move doesn't allow king to be attacked\n\n    const sqrsCovered = this.opposingSquaresCovered(board, piece.type);\n\n    for (let move of sqrsCovered) {\n      if (arrayEquals(move, kingPos)) {\n        board[x][y] = endPiece;\n        board[a][b] = piece;\n        return true;\n      }\n    }\n\n    board[x][y] = endPiece;\n    board[a][b] = piece;\n    return false;\n  }\n\n  move(board, startPos, endPos, piece, kingPos, putInCheck, castleCheck) {\n    const [a, b] = startPos;\n    const [x, y] = endPos;\n    let inCheck = false;\n    let checkmate = false;\n    const kIdx = piece.type ? 0 : 1;\n    const kOppIdx = kIdx ? 0 : 1;\n    const cIdx = piece.type ? 0 : 1;\n    const legalMoves = piece.allowedMoves(board, startPos, piece, kingPos[kIdx], castleCheck[cIdx]);\n\n    if (this.isLegalMove(legalMoves, endPos)) {\n      // If moving piece is king adjust kingPos and castle rights set to false\n      if (piece instanceof King) {\n        kingPos[kIdx] = endPos;\n        castleCheck[cIdx][1] = false;\n      } else if (piece instanceof Rook) {\n        if (a === 0) castleCheck[cIdx][0] = false;else if (a === 7) castleCheck[cIdx][2] = false;\n      }\n\n      board[a][b] = \"-\";\n      board[x][y] = piece; // Sets check in state if put opponent in check\n\n      const inCheck = this.checkedOpponent(board, piece.type, kingPos[kOppIdx]);\n\n      if (inCheck && this.isCheckmate(board, startPos, piece, kingPos[kOppIdx])) {\n        return [false, kingPos, true, true, false];\n      }\n\n      return [board, kingPos, inCheck, checkmate, castleCheck];\n    }\n\n    return [false, kingPos, inCheck, checkmate, castleCheck];\n  }\n\n}\n\nexport default ChessGame;","map":{"version":3,"names":["arrayEquals","King","Rook","Piece","BLACK","WHITE","ChessGame","constructor","turn","isLegalMove","legalMoves","endPos","move","checkedOpponent","board","oppKingPos","squaresCovered","sqr","r","c","piece","type","forEach","m","push","isCheckmate","startPos","kingOppPos","oppStartPos","lMoves","console","log","imgName","x","y","originalPos","moveSquare","some","s","kingUnderAttack","kingPos","a","b","endPiece","sqrsCovered","opposingSquaresCovered","putInCheck","castleCheck","inCheck","checkmate","kIdx","kOppIdx","cIdx","allowedMoves"],"sources":["/Users/benjamincritoph/Programming/React/chess/src/ChessGame.js"],"sourcesContent":["import { arrayEquals } from './Helpers';\nimport { King, Rook, Piece } from './Pieces';\n\nconst BLACK = false;\nconst WHITE = true;\n\nclass ChessGame {\n  constructor(){\n    this.turn = WHITE;\n  }\n  isLegalMove(legalMoves, endPos){\n    // Check that move is legal\n    for(let move of legalMoves){\n      if(arrayEquals(move, endPos)){\n        return true;\n      }\n    }\n  }\n  checkedOpponent(board, turn, oppKingPos) {\n    const squaresCovered = this.squaresCovered(board, turn);\n    for (let sqr of squaresCovered) {\n      if (arrayEquals(sqr, oppKingPos)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  squaresCovered(board, turn) {\n    let squaresCovered = [];\n    for (let r = 0; r < 8; r++) {\n      for (let c = 0; c < 8; c++) {\n        if (board[r][c] instanceof Piece) {\n          const piece = board[r][c];\n          if (turn === piece.type) {\n            piece.legalMoves(board, [r, c], piece).forEach(m => squaresCovered.push(m));\n          }\n        }\n      }\n    }\n    return squaresCovered;\n  }\n  isCheckmate(board, startPos, piece, kingOppPos){\n    // Check every move you can to see if opponent can get out of check\n    for (let r = 0; r < 8; r++) {\n      for (let c = 0; c < 8; c++) {\n        const oppStartPos = board[r][c];\n        if (oppStartPos instanceof Piece && oppStartPos.type !== piece.type) {\n          const lMoves = oppStartPos.legalMoves(board, [r, c], piece);\n          console.log(\"Piece lmoves\");\n          console.log(`r = ${r}, c = ${c}`);\n          console.log(oppStartPos.imgName);\n          console.log(lMoves);\n          for (let move of lMoves) {\n            const [x, y] = move;\n            let originalPos = board[r][c];\n            let moveSquare = board[x][y]; \n            board[r][c] = \"-\";\n            board[x][y] = piece;\n            const squaresCovered = this.squaresCovered(board, piece.type);\n            if (!squaresCovered.some(s => arrayEquals(s, kingOppPos))) {\n              board[r][c] = originalPos;\n              board[x][y] = moveSquare;\n              console.log(\"squaresCovered\");\n              console.log(squaresCovered);\n              console.log(\"kingOppPos\");\n              console.log(kingOppPos);\n              return false;\n            }\n            board[x][y] = moveSquare;\n            board[r][c] = originalPos;\n          }\n        }\n      }\n    }\n    return true;\n\n    // for (let move of oppSquaresCovered) {\n    //   const [x, y] = move;\n    //   board[a][b] = \"-\";\n    //   const moveSquare = board[x][y]; \n    //   board[x][y] = piece;\n    //   // If opponent can escape check with their move checkmate is false \n    //   if (!squaresCovered.some(s => arrayEquals(s, kingOppPos))) {\n    //     return false;\n    //   }\n    //   board[x][y] = moveSquare;\n    // }\n    // // If opponent can't escape it's CHECKMATE!\n    // return true;\n  }\n  kingUnderAttack(board, startPos, endPos, piece, kingPos) {\n    if (piece instanceof King) kingPos = endPos;\n    const [a, b] = startPos;\n    const [x, y] = endPos;\n    // const newBoard = board.map(o => o);\n    const endPiece = board[x][y];\n    board[a][b] = \"-\";\n    board[x][y] = piece;\n    // Check move doesn't allow king to be attacked\n    const sqrsCovered = this.opposingSquaresCovered(board, piece.type);\n    for (let move of sqrsCovered) {\n      if (arrayEquals(move, kingPos)) {\n        board[x][y] = endPiece;\n        board[a][b] = piece;\n        return true;\n      }\n    }\n    board[x][y] = endPiece;\n    board[a][b] = piece;\n    return false;\n  } \n  move(board, startPos, endPos, piece, kingPos, putInCheck, castleCheck) {\n    const [a, b] = startPos;\n    const [x, y] = endPos;\n    let inCheck = false;\n    let checkmate = false;\n    const kIdx = piece.type? 0 : 1;\n    const kOppIdx = kIdx? 0: 1;\n    const cIdx = piece.type? 0 : 1;\n    const legalMoves = piece.allowedMoves(board, startPos, piece, kingPos[kIdx], castleCheck[cIdx]);\n    if (this.isLegalMove(legalMoves, endPos)) {\n      // If moving piece is king adjust kingPos and castle rights set to false\n      if (piece instanceof King) {\n        kingPos[kIdx] = endPos;\n        castleCheck[cIdx][1] = false;\n      }\n      else if (piece instanceof Rook) {\n        if (a === 0) castleCheck[cIdx][0] = false;\n        else if (a === 7) castleCheck[cIdx][2] = false;\n      }\n      board[a][b] = \"-\";\n      board[x][y] = piece;\n      // Sets check in state if put opponent in check\n      const inCheck = this.checkedOpponent(board, piece.type, kingPos[kOppIdx]);\n      if (inCheck && this.isCheckmate(board, startPos, piece, kingPos[kOppIdx])) {\n        return [false, kingPos, true, true, false];\n      }\n      return [board, kingPos, inCheck, checkmate, castleCheck];\n    }\n    return [false, kingPos, inCheck, checkmate, castleCheck];\n  }\n}\n\nexport default ChessGame;"],"mappings":"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"},"metadata":{},"sourceType":"module"}