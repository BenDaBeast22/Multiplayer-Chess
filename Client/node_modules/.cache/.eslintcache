[{"/Users/benjamincritoph/Programming/React/chess/Client/src/index.js":"1","/Users/benjamincritoph/Programming/React/chess/Client/src/App.js":"2","/Users/benjamincritoph/Programming/React/chess/Client/src/Board.js":"3","/Users/benjamincritoph/Programming/React/chess/Client/src/Square.js":"4","/Users/benjamincritoph/Programming/React/chess/Client/src/Pieces.js":"5","/Users/benjamincritoph/Programming/React/chess/Client/src/Helpers.js":"6","/Users/benjamincritoph/Programming/React/chess/Client/src/ChessGame.js":"7","/Users/benjamincritoph/Programming/React/chess/Client/src/Chat.js":"8","/Users/benjamincritoph/Programming/React/chess/Client/src/connections/socket.js":"9","/Users/benjamincritoph/Programming/React/chess/Client/src/Game.js":"10","/Users/benjamincritoph/Programming/React/chess/Client/src/gameRoom/CreateGame.js":"11","/Users/benjamincritoph/Programming/React/chess/Client/src/gameRoom/JoinGameRoom.js":"12"},{"size":347,"mtime":1666148161864,"results":"13","hashOfConfig":"14"},{"size":792,"mtime":1666196071229,"results":"15","hashOfConfig":"14"},{"size":8876,"mtime":1666124835389,"results":"16","hashOfConfig":"14"},{"size":2874,"mtime":1666053971165,"results":"17","hashOfConfig":"14"},{"size":10876,"mtime":1665681509494,"results":"18","hashOfConfig":"14"},{"size":1443,"mtime":1665084227765,"results":"19","hashOfConfig":"14"},{"size":7242,"mtime":1665677161726,"results":"20","hashOfConfig":"14"},{"size":1391,"mtime":1666124150934,"results":"21","hashOfConfig":"14"},{"size":273,"mtime":1666198351846,"results":"22","hashOfConfig":"14"},{"size":204,"mtime":1666147819931,"results":"23","hashOfConfig":"14"},{"size":1643,"mtime":1666192383887,"results":"24","hashOfConfig":"14"},{"size":1049,"mtime":1666197237973,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},"fyh50c",{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"33","messages":"34","suppressedMessages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"29"},{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"29"},{"filePath":"41","messages":"42","suppressedMessages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"29"},{"filePath":"45","messages":"46","suppressedMessages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"29"},{"filePath":"49","messages":"50","suppressedMessages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"29"},{"filePath":"53","messages":"54","suppressedMessages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"56","messages":"57","suppressedMessages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"59","messages":"60","suppressedMessages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"29"},{"filePath":"62","messages":"63","suppressedMessages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"65","messages":"66","suppressedMessages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/benjamincritoph/Programming/React/chess/Client/src/index.js",[],[],[],"/Users/benjamincritoph/Programming/React/chess/Client/src/App.js",["68","69","70"],[],"/Users/benjamincritoph/Programming/React/chess/Client/src/Board.js",["71","72","73","74","75","76","77","78","79"],[],"import './Board.css'\nimport React from 'react'\nimport Square from './Square';\nimport { Piece, King, Queen, Knight, Bishop, Rook } from './Pieces';\nimport { arrayEquals, setupBoard } from './Helpers';\nimport { Howl, Howler } from 'howler';\nimport ChessGame from './ChessGame';\nconst socket = require(\"./connections/socket\").socket;\n\nconst BLACK = false\nconst WHITE = true\n\nconst soundEffects = {\n  whiteMove: \"./whiteMove.wav\",\n  blackMove: \"./blackMove.wav\"\n}\n\nlet Game = new ChessGame();\n\nclass Board extends React.Component {\n  static defaultProps = {\n    nRows: 8,\n    nCols: 8,\n  }\n  constructor(props) {\n    super(props);\n    this.state = {\n      board: setupBoard(),\n      lastSelectedPiecePos: false,\n      turn: WHITE,\n      legalMoves: [],\n      kingPos: [[0, 4], [7, 4]],\n      inCheck: false,\n      checkmate: false,\n      winner: false,\n      castleCheck: [[true, true, true], [true, true, true]],\n      lastEnPassant: false,\n      draw: false, \n      promotePawn: false, \n      \n    }\n    this.resetBoard = this.resetBoard.bind(this);\n    this.dropMove = this.dropMove.bind(this);\n    this.selectPromote = this.selectPromote.bind(this);\n  }\n  // Checks to see if another piece is selected\n  changeSelection(board, selectedPiece, newPos) {\n    const [r, c] = newPos;\n    const [or, oc] = selectedPiece;\n    if ((board[or][oc].type === board[r][c].type) && !(or === r && oc === c)) {\n      return true;\n    }\n    return false;\n  }\n  // Called when a player promotes a pawn and selects piece to promote to\n  selectPromote(selectedPiecePos, newPiece) {\n    const [pr, pc] = selectedPiecePos;\n    const {kingPos, castleCheck, lastEnPassant, turn} = this.state;\n    const kIdx = newPiece.type? 0 : 1;\n    const kOppIdx = kIdx? 0: 1;\n    const newBoard = this.state.board;\n    newBoard[pr][pc] = newPiece;\n    console.log(\"color\", turn === WHITE? \"White\": \"Black\");\n\n    // Check if opponent in check\n    const inCheck = Game.checkedOpponent(newBoard, newPiece.type, kingPos[kOppIdx]);\n    // Check for checkmate\n    if (inCheck && Game.isCheckmate(newBoard, newPiece, kingPos[kOppIdx])) {\n      console.log(\"CHEKMATE\")\n      this.setState({board: newBoard, winner: newPiece.type, checkmate: true, inCheck: true, legalMoves: [], lastSelectedPiecePos: false, promotePawn: false});\n    }\n    // Check for draw\n    else if (Game.draw(newBoard, newPiece, kingPos[kOppIdx], castleCheck, lastEnPassant)) {\n      this.setState({board: newBoard, draw: true, legalMoves: [], lastSelectedPiecePos: false, promotePawn: false});\n    } \n    else {\n      this.setState({\n        board: newBoard, \n        lastSelectedPiecePos: false, \n        legalMoves: [], \n        inCheck: inCheck, \n        promotePawn: false\n      });\n    }\n  }\n\n  // Called when player clicks on a piece\n  selectPiece(selectedPiecePos) {\n    const [r, c] = selectedPiecePos;\n    const {board, lastSelectedPiecePos, kingPos, inCheck, castleCheck, lastEnPassant, draw, turn, promotePawn} = this.state;\n\n    // If a move is made\n    if (lastSelectedPiecePos && !this.changeSelection(board, lastSelectedPiecePos, selectedPiecePos)) {\n      if (arrayEquals(selectedPiecePos, lastSelectedPiecePos)){\n        this.setState({lastSelectedPiecePos: false, legalMoves: []})\n        return;\n      } \n      const [or, oc] = lastSelectedPiecePos;\n      const lastSelectedPiece = board[or][oc];\n      const retBoard = Game.move(board, lastSelectedPiecePos, selectedPiecePos, lastSelectedPiece, kingPos, inCheck, castleCheck, lastEnPassant, draw);\n      if (retBoard.checkmate) {\n        this.setState({winner: lastSelectedPiece.type, checkmate: true, inCheck: true, legalMoves: [], lastSelectedPiecePos: false, turn: !turn});\n        return;\n      }\n      else if (retBoard.draw) {\n        this.setState({draw: true, legalMoves: [], lastSelectedPiecePos: false, turn: !turn});\n        return;\n      }\n      else if (retBoard.board){\n        this.setState({\n          board: retBoard.board, \n          lastSelectedPiecePos: false, \n          turn: !turn, \n          legalMoves: [], \n          kingPos: retBoard.kingPos, \n          inCheck: retBoard.inCheck, \n          checkmate: retBoard.checkmate, \n          castleCheck: retBoard.castleCheck, \n          lastEnPassant: retBoard.lastEnPassant,\n          promotePawn: retBoard.promotePawn\n        });\n        // socket.emit(\"move\", board);\n        if (turn === WHITE) {\n          this.playSound(\"./soundEffects/whiteMove.wav\");\n        }\n        else this.playSound(\"./soundEffects/blackMove.wav\");\n      } \n      return;\n    }\n    // If piece is selected or switch to another piece\n    const selectedPiece = board[r][c];\n    if (!selectedPiece instanceof Piece || selectedPiece.type !== turn) return;\n    const kIdx = selectedPiece.type? 0 : 1;\n    const cIdx = selectedPiece.type? 0 : 1;\n    // Show legal moves when piece is selected\n    const lMoves = selectedPiece.allowedMoves(board, selectedPiecePos, selectedPiece, kingPos[kIdx], castleCheck[cIdx], lastEnPassant);\n    this.setState({lastSelectedPiecePos: selectedPiecePos, legalMoves: lMoves});\n  }\n  dropMove(movedSqr) {\n    this.selectPiece(movedSqr);\n  }\n  playSound(src) {\n    const sound = new Howl({src});\n    sound.play();\n  }\n  selectorSquares (pawnPromote) {\n    let arr = [];\n    const [r, c] = pawnPromote;\n    const turn = (r === 7)? WHITE : BLACK;\n    if (turn === WHITE) {\n      arr.push(\n        new Bishop(WHITE, \"w_b\"),\n        new Rook(WHITE, \"w_r\"), \n        new Knight(WHITE, \"w_kn\"), \n        new Queen(WHITE, \"w_q\") \n      );\n    } else {\n      arr.push(\n        new Queen(BLACK, \"b_q\"),\n        new Knight(BLACK, \"b_kn\"),\n        new Rook(BLACK, \"b_r\"),\n        new Bishop(BLACK, \"b_b\")\n      );\n    }\n    return arr;\n  }\n  selectorSquare (pawnPromote, selectSquares, pos){\n    const [pr, pc] = pawnPromote;\n    const [r, c] = pos;\n    const turn = (pr === 7)? WHITE : BLACK;\n    if (turn === WHITE) {\n      if (c === pc && (r >= 4 && r < 8)) {\n        console.log(\"pr = \",pr)\n        return selectSquares[r - 4];\n      }\n    } else {\n      if (c === pc && (r <= 3)) {\n        return selectSquares[r];\n      }\n    }\n  }\n  // Resets chessboard state\n  resetBoard(){\n    this.setState({\n      board: setupBoard(), \n      lastSelectedPiecePos: false, \n      turn: WHITE, \n      legalMoves: [], \n      kingPos: [[0, 4], [7, 4]], \n      inCheck: false, \n      checkmate: false,\n      winner: false,\n      castleCheck: [[true, true, true], [true, true, true]],\n      lastEnPassant: false, \n      draw: false,\n      promotePawn: false\n    });\n    Game = new ChessGame();\n  }\n  render(){\n    // socket.on(\"move\", board => {\n    //   this.setState({board: board})\n    //   console.log(\"newBoard = \", board);\n    // });\n    const {board, lastSelectedPiecePos, turn, legalMoves, inCheck, checkmate, draw, winner, promotePawn} = this.state;\n    let winMessage = <div>{winner? \"White Wins!!!\" : \"Black Wins!!!\"}</div>\n    let chessBoard = [];\n    let cOdd = true;\n    let rOdd = true;\n    let selectorSquares;\n    let selectorSquare;\n    let pr, pc;\n    if (promotePawn) {\n      selectorSquares = this.selectorSquares(promotePawn);\n      console.log(selectorSquares);\n    }\n    // Iterated through rows backwards so that white would be at row 0 similar to chess notation\n    for(let r = 7; r >= 0; r--){\n      let row = [] \n      cOdd = rOdd;\n      for(let c = 0; c < this.props.nCols; c++){\n        const sqr = `${String.fromCharCode(97 + c)}${r + 1}`;\n        const isDark = cOdd? true: false;\n        const piece = board[r][c];\n        const pos = [r, c];\n        const isSelected = arrayEquals(pos, lastSelectedPiecePos);\n        const isLegalMove = legalMoves.some(lm => arrayEquals(lm, pos)? true : false);\n        const isDraw = draw && piece instanceof King && (turn === piece.type);\n        const kingInCheck = piece instanceof King && inCheck && (turn === piece.type);\n        selectorSquare = false;\n        if (promotePawn) {\n          [pr, pc] = promotePawn;\n          selectorSquare = this.selectorSquare(promotePawn, selectorSquares, pos); \n          console.log(selectorSquare)\n        }\n        row.push(<Square key={sqr} pos={pos} isDark={isDark} piece={piece} selectPiece={() => this.selectPiece([r,c])} isSelected={isSelected} isLegal={isLegalMove} inCheck={kingInCheck} isCheckmate={checkmate} draw={isDraw} dropMove={this.dropMove} selectorSquare={selectorSquare} selectPromote={this.selectPromote} promotePos={promotePawn} turn={turn}/>)\n        cOdd = !cOdd;\n      }\n      chessBoard.push(<tr className=\"Row\" key={r + 1}>{row}</tr>)   \n      rOdd = !rOdd;  \n    }\n    // Render Chess Pieces\n    return (\n      <div className=\"Board noselect\">\n        <table className=\"Table\">\n          <tbody>\n            {chessBoard}\n          </tbody>\n        </table>\n        <button onClick={this.resetBoard}className=\"newGame\">New Game</button>\n      </div>\n    );\n  }\n}\n\nexport default Board;","/Users/benjamincritoph/Programming/React/chess/Client/src/Square.js",["80","81","82"],[],"import './Square.css';\nimport React from 'react';\n// Chess piece images: https://commons.wikimedia.org/wiki/Category:SVG_chess_pieces\n\nclass Square extends React.Component {\n  constructor(props){\n    super(props);\n    this.state = {dragOver: false}\n    this.handleClick = this.handleClick.bind(this);\n    this.handleDragStart = this.handleDragStart.bind(this);\n    this.handleDragOver = this.handleDragOver.bind(this);\n    this.handleDrop = this.handleDrop.bind(this);\n    this.handleDragLeave = this.handleDragLeave.bind(this);\n    this.handlePromote = this.handlePromote.bind(this);\n  }\n  handleClick() {\n    if (this.props.isCheckmate || this.props.draw) {\n      return;\n    }\n    this.props.selectPiece();\n  }\n  handleDragStart(e) {\n    // e.dataTransfer.setData(\"pos\", this.props.pos);\n    // e.dataTransfer.setData(\"piece\", this.props.piece);\n    e.dataTransfer.effectAllowed = \"move\";\n    if (this.props.isCheckmate || this.props.draw) {\n      return;\n    }\n    if (!this.props.isSelected) this.props.selectPiece();\n    // e.transfer.setData(\"pos\", this.props.pos);\n  }\n  handleDragOver(e) {\n    e.stopPropagation();\n    e.preventDefault();\n    this.setState({dragOver: true})\n  }\n  handleDragLeave(e) {\n    this.setState({dragOver: false});\n  }\n  handleDrop(e) {\n    e.preventDefault();\n    if (this.props.isCheckmate || this.props.draw) {\n      return;\n    }\n    // const selectedPiece = e.dataTransfer.getData(\"pos\");\n    const movedSqr = this.props.pos;\n    this.setState({dragOver: false});\n    this.props.dropMove(movedSqr);\n  }\n  handlePromote() {\n    const {promotePos, selectorSquare, selectPromote} = this.props;\n    selectPromote(promotePos, selectorSquare);\n  }\n  render(){\n    const {piece, isLegal, selectorSquare, turn} = this.props;\n    const {dragOver} = this.state;\n    const classes = \"square\" + (this.props.isDark ? \" dark\" : \" light\") + (this.props.isSelected ? \" selected\": \"\" + (this.props.inCheck ? \" inCheck\": \"\") + (this.props.draw ? \" draw\" : \"\"));\n    const pieceClasses = \"piece\" + (isLegal? \" capture\": \"\");\n    const dragClasses = (dragOver && isLegal) ? \" hover\" : \"\";\n    return (\n      <>\n        {\n          !selectorSquare?\n            <td onClick={this.handleClick} className={classes+dragClasses} onDragOver={this.handleDragOver} onDrop={this.handleDrop} onDragLeave={this.handleDragLeave}>\n            {\n              piece !== '-'? \n                <img className={pieceClasses} src={`./images/${piece.imgName}.png`} onDragStart={this.handleDragStart}/>\n              : \n                <i className={`${isLegal && !dragOver? 'fa-solid fa-circle legal': ''}`}/>\n            }\n            </td>\n          :\n          <td className=\"Selector\" onClick={this.handlePromote}>\n            <img className=\"piece\" src={`./images/${selectorSquare.imgName}.png`}/>\n          </td>\n        }\n      </>\n    );\n  }\n}\n\nexport default Square;","/Users/benjamincritoph/Programming/React/chess/Client/src/Pieces.js",["83","84","85","86","87","88","89","90"],[],"import {arrayEquals} from './Helpers';\nconst BLACK = false;\nconst WHITE = true;\n\n// Abstract Class\nclass Piece {\n  constructor(type, img){\n    if(this.constructor === Piece){\n      throw new Error('Class \"Piece\" cannot be instantiated');\n    }\n    this.type = type;\n    this.imgName = img;\n  }\n  // True if row and column are on the board (8x8)\n  onBoard(r, c){\n    if(r > 7 || r < 0 || c > 7 || c < 0){\n      return false;\n    }\n    return true;\n  }\n  isPiece(piece) {\n    if (piece instanceof Piece) return true;\n    return false;\n  }\n  // True if piece on the square is the same color as the piece you are moving\n  sameColor(sqr, piece){\n    if(sqr instanceof Piece && sqr.type === piece.type){\n      return true;\n    }\n    return false;\n  }\n  isOppositePiece(sqr, piece) {\n    if (sqr.type !== piece.type) return true;\n    return false;\n  }\n  emptySquare(sqr) {\n    return !(sqr instanceof Piece);\n  }\n  straightLegalMoves(board, startPos, piece, off) {\n    const lMoves = [];\n    const [rStart, cStart] = startPos;\n    for (let r = rStart + off; this.onBoard(r, cStart); r += off) {\n      if (this.isPiece(board[r][cStart])) {\n        if (this.isOppositePiece(board[r][cStart], piece)) {\n          lMoves.push([r, cStart]);\n        }\n        break;\n      }\n      lMoves.push([r, cStart]);\n    }\n    return lMoves;\n  }\n  horizantalLegalMoves(board, startPos, piece, off) {\n    const lMoves = [];\n    const [rStart, cStart] = startPos;\n    for (let c = cStart + off; this.onBoard(rStart, c); c += off) {\n      if (this.isPiece(board[rStart][c])) {\n        if (this.isOppositePiece(board[rStart][c], piece)) {\n          lMoves.push([rStart, c]);\n        }\n        break;\n      }\n      lMoves.push([rStart, c]);\n    }\n    return lMoves;\n  }\n  diagonalLegalMoves(board, startPos, piece, rOff, cOff) {\n    const lMoves = [];\n    const [rStart, cStart] = startPos;\n    let r = rStart + rOff;\n    let c = cStart + cOff;\n    while (this.onBoard(r, c)) {\n      if (this.isPiece(board[r][c])) {\n        if (this.isOppositePiece(board[r][c], piece)) {\n          lMoves.push([r, c]);\n        }\n        break;\n      }\n      lMoves.push([r, c]);\n      r += rOff;\n      c += cOff;\n    }\n    return lMoves;\n  }\n  arrayLegalMoves(board, startPos, piece, moves) {\n    let lMoves = [];\n    const [rStart, cStart] = startPos;\n    for(let move of moves){\n      const [rOff, cOff] = move;\n      let r = rStart + rOff;\n      let c = cStart + cOff;\n      // If move sqr is on the board and does not have one of your pieces on it move is valid\n      if(this.onBoard(r, c) && !this.sameColor(board[r][c], piece)){\n        lMoves.push([r, c]);\n      }  \n    }\n    return lMoves;  \n  }\n  opposingSquaresCovered(board, turn) {\n    let squaresCovered = [];\n    // console.log(board);\n    for (let r = 0; r < 8; r++) {\n      for (let c = 0; c < 8; c++) {\n        if (board[r][c] instanceof Piece) {\n          const piece = board[r][c];\n          if (turn !== piece.type) {\n            piece.legalMoves(board, [r, c], piece).forEach(m => squaresCovered.push(m));\n          }\n        }\n      }\n    }\n    return squaresCovered;\n  }\n  kingUnderAttack(board, startPos, endPos, piece, kingPos) {\n    if (piece instanceof King) kingPos = endPos;\n    const [a, b] = startPos;\n    const [x, y] = endPos;\n    // const newBoard = board.map(o => o);\n    const endPiece = board[x][y];\n    board[a][b] = \"-\";\n    board[x][y] = piece;\n    // Check move doesn't allow king to be attacked\n    const sqrsCovered = this.opposingSquaresCovered(board, piece.type);\n    for (let move of sqrsCovered) {\n      if (arrayEquals(move, kingPos)) {\n        board[x][y] = endPiece;\n        board[a][b] = piece;\n        return true;\n      }\n    }\n    board[x][y] = endPiece;\n    board[a][b] = piece;\n    return false;\n  }\n  enPassant(sqr, lastEnPassant) {\n    return arrayEquals(sqr, lastEnPassant);\n  } \n}\n\nclass Pawn extends Piece {\n  constructor(type, img){\n    super(type, img);\n  }\n  legalMoves(board, pawnPos, pawn, lastEnPassant) {\n    let lMoves = [];\n    const [rStart, cStart] = pawnPos;\n    let upOne = [];\n    let upOneRight = [];\n    let upOneLeft = [];\n    let ecOff;\n    if (pawn.type === WHITE) {\n      ecOff = 1;\n      upOne = [rStart + 1, cStart];\n      // Add up two legal move\n      if(rStart === 1 && this.emptySquare(board[rStart + 2][cStart])) {\n        lMoves.push([rStart + 2, cStart]);\n      }\n      upOneRight = [rStart + 1, cStart + 1];\n      upOneLeft = [rStart + 1, cStart - 1];\n    } \n    else {\n      ecOff = -1;\n      upOne = [rStart - 1, cStart];\n      // Add up two legal move\n      if(rStart === 6 && this.emptySquare(board[rStart - 2][cStart])) {\n        lMoves.push([rStart - 2, cStart]);\n      }\n      upOneRight = [rStart - 1, cStart + 1];\n      upOneLeft = [rStart - 1, cStart - 1];\n    }\n    // Add up one legal move\n    const [uor, uoc] = upOne;\n    if (this.onBoard(uor, uoc) && this.emptySquare(board[uor][uoc])) lMoves.push(upOne);\n    // Add diagonal legal moves\n    const diagonal = [upOneRight, upOneLeft];\n    for (let move of diagonal) {\n      const [rd, rc] = move;\n      if (this.onBoard(rd, rc) && this.isPiece(board[rd][rc]) && this.isOppositePiece(board[rd][rc], pawn)) {\n        lMoves.push([rd, rc])\n      }\n      if (this.enPassant([rd, rc], lastEnPassant)) {\n        lMoves.push([rd, rc]);\n      }\n    }\n    return lMoves;\n  }\n  allowedMoves(board, pawnPos, pawn, kingPos, castleCheck, lastEnPassant) {\n    const lMoves = this.legalMoves(board, pawnPos, pawn, lastEnPassant);\n    const aMoves = lMoves.filter(m => !this.kingUnderAttack(board, pawnPos, m, pawn, kingPos));\n    return aMoves;\n  }\n}\n\nclass Bishop extends Piece {\n  constructor(type, img){\n    super(type, img);\n  }\n  legalMoves(board, bishopPos, bishop) {\n    let lMoves = [];\n    this.diagonalLegalMoves(board, bishopPos, bishop, 1, 1).forEach(m => lMoves.push(m)); // Up right\n    this.diagonalLegalMoves(board, bishopPos, bishop, 1, -1).forEach(m => lMoves.push(m)); // Up left\n    this.diagonalLegalMoves(board, bishopPos, bishop, -1, 1).forEach(m => lMoves.push(m)); // Down right\n    this.diagonalLegalMoves(board, bishopPos, bishop, -1, -1).forEach(m => lMoves.push(m)); // Down left\n    return lMoves;\n  }\n  allowedMoves(board, bishopPos, bishop, kingPos) {\n    const lMoves = this.legalMoves(board, bishopPos, bishop);\n    const aMoves = lMoves.filter(m => !this.kingUnderAttack(board, bishopPos, m, bishop, kingPos));\n    return aMoves;\n  }\n}\n\nclass Rook extends Piece {\n  constructor(type, img){\n    super(type, img);\n  }\n  legalMoves(board, rookPos, rook) {\n    let lMoves = [];\n    this.straightLegalMoves(board, rookPos, rook, 1).forEach(m => lMoves.push(m)); // Up\n    this.straightLegalMoves(board, rookPos, rook, -1).forEach(m => lMoves.push(m)); // Down\n    this.horizantalLegalMoves(board, rookPos, rook, 1).forEach(m => lMoves.push(m)); // Right\n    this.horizantalLegalMoves(board, rookPos, rook, -1).forEach(m => lMoves.push(m)); // Left\n    return lMoves;\n  }\n  allowedMoves(board, rookPos, rook, kingPos) {\n    const lMoves = this.legalMoves(board, rookPos, rook);\n    const aMoves = lMoves.filter(m => !this.kingUnderAttack(board, rookPos, m, rook, kingPos));\n    return aMoves;\n  }\n}\n\nclass Queen extends Piece {\n  constructor(type, img){\n    super(type, img);\n  }\n  legalMoves(board, queenPos, queen) {\n    let lMoves = [];\n    this.straightLegalMoves(board, queenPos, queen, 1).forEach(m => lMoves.push(m)); // Up\n    this.straightLegalMoves(board, queenPos, queen, -1).forEach(m => lMoves.push(m)); // Down\n    this.horizantalLegalMoves(board, queenPos, queen, 1).forEach(m => lMoves.push(m)); // Right\n    this.horizantalLegalMoves(board, queenPos, queen, -1).forEach(m => lMoves.push(m)); // Left\n    this.diagonalLegalMoves(board, queenPos, queen, 1, 1).forEach(m => lMoves.push(m)); // Up right\n    this.diagonalLegalMoves(board, queenPos, queen, 1, -1).forEach(m => lMoves.push(m)); // Up left\n    this.diagonalLegalMoves(board, queenPos, queen, -1, 1).forEach(m => lMoves.push(m)); // Down right\n    this.diagonalLegalMoves(board, queenPos, queen, -1, -1).forEach(m => lMoves.push(m)); // Down left\n    return lMoves;\n  }\n  allowedMoves(board, queenPos, queen, kingPos) {\n    const lMoves = this.legalMoves(board, queenPos, queen);\n    const aMoves = lMoves.filter(m => !this.kingUnderAttack(board, queenPos, m, queen, kingPos));\n    return aMoves;\n  }\n}\n\nclass Knight extends Piece {\n  constructor(type, img){\n    super(type, img);\n  }\n  legalMoves(board, knightPos, knight) {\n    let lMoves = [];\n    const [rStart, cStart] = knightPos;\n    const moves = [[1,2], [-1,2], [1,-2], [-1,-2], [2,1], [-2,1], [2,-1], [-2,-1]];\n    for(let move of moves){\n      const [rOff, cOff] = move;\n      let r = rStart + rOff;\n      let c = cStart + cOff;\n      // If move sqr is on the board and does not have one of your pieces on it move is valid\n      if(this.onBoard(r, c) && !this.sameColor(board[r][c], knight)){\n        const lMove = [r, c];\n        lMoves.push(lMove);\n      }  \n    }\n    return lMoves;  \n  }\n  allowedMoves(board, knightPos, knight, kingPos) {\n    const lMoves = this.legalMoves(board, knightPos, knight);\n    const aMoves = lMoves.filter(m => !this.kingUnderAttack(board, knightPos, m, knight, kingPos));\n    return aMoves;\n  }\n}\n\nclass King extends Piece {\n  constructor(type, img){\n    super(type, img);\n  }\n  castleMoves(board, kingPos, castleCheck, king) {\n    const cMoves = [];\n    const [r, c] = kingPos;\n    if (castleCheck[1] && castleCheck[2]) {\n      let rightCastle = true;\n      for (let i = 1; i <= 2; i++) {\n        if (!this.emptySquare(board[r][c + i]) || this.kingUnderAttack(board, kingPos, [r, c + i], king)) {\n          rightCastle = false;\n        }\n      }\n      if (rightCastle) cMoves.push([r, c + 2]); \n    }\n    if (castleCheck[1] && castleCheck[0]) {\n      let leftCastle = true;\n      for (let i = 1; i <= 2; i++) {\n        if (!this.emptySquare(board[r][c - i]) || this.kingUnderAttack(board, kingPos, [r, c - i], king)) {\n          leftCastle = false;\n        }\n      }\n      if (!this.emptySquare(board[r][c - 3])) leftCastle = false;\n      if (leftCastle) cMoves.push([r, c - 2], [r, c - 3]);\n    }\n    return cMoves;\n  }\n  legalMoves(board, kingPos, king) {\n    let lMoves = [];\n    const moves = [\n      [1, -1], [1, 0], [1, 1],\n      [0, -1],         [0, 1],\n      [-1,-1], [-1,0], [-1,1]\n    ];\n    this.arrayLegalMoves(board, kingPos, king, moves).forEach(m => lMoves.push(m));\n    return lMoves;\n  }\n  allowedMoves(board, piecePos, king, kingPos, castleCheck) {\n    let lMoves = this.legalMoves(board, piecePos, king);\n    if (castleCheck) this.castleMoves(board, piecePos, castleCheck, king).forEach(m => {\n      if (m)\n      lMoves.push(m)\n    });\n    const aMoves = lMoves.filter(m => !this.kingUnderAttack(board, piecePos, m, king));\n    return aMoves;\n  }\n}\n\n\nexport {Piece, Pawn, Bishop, Knight, Rook, Queen, King};\n","/Users/benjamincritoph/Programming/React/chess/Client/src/Helpers.js",["91"],[],"import {Piece, Pawn, Bishop, Knight, Rook, Queen, King} from './Pieces';\nconst BLACK = false;\nconst WHITE = true;\n\n\nfunction arrayEquals(a, b) {\n  return Array.isArray(a) &&\n      Array.isArray(b) &&\n      a.length === b.length &&\n      a.every((val, index) => val === b[index]);\n}\n\n// Sets up chessboard array with pieces\nfunction setupBoard() {\n  let board = [];\n  // Generate Empty Board\n  for (let r = 0; r < 8; r++) {\n    let row = []\n    for (let c = 0; c < 8; c++) {\n      row.push(\"-\") \n    }\n    board.push(row)\n  }\n  // Display White Pieces\n  board[0][0] = new Rook(WHITE, \"w_r\");\n  board[0][1] = new Knight(WHITE, \"w_kn\");\n  board[0][2] = new Bishop(WHITE, \"w_b\");\n  board[0][3] = new Queen(WHITE, \"w_q\");\n  board[0][4] = new King(WHITE, \"w_k\");\n  board[0][5] = new Bishop(WHITE, \"w_b\");\n  board[0][6] = new Knight(WHITE, \"w_kn\");\n  board[0][7] = new Rook(WHITE, \"w_r\");\n  // Display Black Pieces\n  board[7][0] = new Rook(BLACK, \"b_r\");\n  board[7][1] = new Knight(BLACK, \"b_kn\");\n  board[7][2] = new Bishop(BLACK, \"b_b\");\n  board[7][3] = new Queen(BLACK, \"b_q\");\n  board[7][4] = new King(BLACK, \"b_k\");\n  board[7][5] = new Bishop(BLACK, \"b_b\");\n  board[7][6] = new Knight(BLACK, \"b_kn\");\n  board[7][7] = new Rook(BLACK, \"b_r\");\n  // Display Pawns\n  for(let c = 0; c < 8; c++){\n    board[1][c] = new Pawn(WHITE, \"w_p\", [1, c]);\n    board[6][c] = new Pawn(BLACK, \"b_p\", [6, c]);\n  }\n  return board;\n}\nexport {arrayEquals, setupBoard};","/Users/benjamincritoph/Programming/React/chess/Client/src/ChessGame.js",["92","93"],[],"import { arrayEquals } from './Helpers';\nimport { King, Rook, Pawn, Piece } from './Pieces';\n\nconst BLACK = false;\nconst WHITE = true;\n\nclass ChessGame {\n  constructor(){\n    this.turn = WHITE;\n  }\n  isLegalMove(legalMoves, endPos){\n    // Check that move is legal\n    for(let move of legalMoves){\n      if(arrayEquals(move, endPos)){\n        return true;\n      }\n    }\n  }\n  checkedOpponent(board, turn, oppKingPos) {\n    const squaresCovered = this.squaresCovered(board, turn);\n    for (let sqr of squaresCovered) {\n      if (arrayEquals(sqr, oppKingPos)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  squaresCovered(board, turn) {\n    let squaresCovered = [];\n    for (let r = 0; r < 8; r++) {\n      for (let c = 0; c < 8; c++) {\n        if (board[r][c] instanceof Piece) {\n          const piece = board[r][c];\n          if (turn === piece.type) {\n            piece.legalMoves(board, [r, c], piece).forEach(m => squaresCovered.push(m));\n          }\n        }\n      }\n    }\n    return squaresCovered;\n  }\n  isCheckmate(board, piece, kingOppPos){\n    // Check every move you can to see if opponent can get out of check \n    const kingOppStartPos = kingOppPos;\n    for (let r = 0; r < 8; r++) {\n      for (let c = 0; c < 8; c++) {\n        const oppStartPos = board[r][c];\n        if (oppStartPos instanceof Piece && oppStartPos.type !== piece.type) {\n          let lMoves;\n          // Need to check allowed moves for king since piece that king cannot take could be putting him in check\n          if (oppStartPos instanceof King) lMoves = oppStartPos.allowedMoves(board, [r, c], board[r][c], kingOppPos);\n          else lMoves = oppStartPos.legalMoves(board, [r, c], board[r][c]);\n          for (let move of lMoves) {\n            const [x, y] = move;\n            let originalPos = board[r][c];\n            let moveSquare = board[x][y]; \n            board[r][c] = \"-\";\n            board[x][y] = oppStartPos;\n            if (oppStartPos instanceof King) kingOppPos = [x, y];\n            const squaresCovered = this.squaresCovered(board, piece.type);\n            if (!squaresCovered.some(s => arrayEquals(s, kingOppPos))) {\n              board[r][c] = originalPos;\n              board[x][y] = moveSquare;\n              if (oppStartPos instanceof King) kingOppPos = kingOppStartPos;\n              return false;\n            }\n            board[x][y] = moveSquare;\n            board[r][c] = originalPos;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  kingUnderAttack(board, startPos, endPos, piece, kingPos) {\n    if (piece instanceof King) kingPos = endPos;\n    const [a, b] = startPos;\n    const [x, y] = endPos;\n    const endPiece = board[x][y];\n    board[a][b] = \"-\";\n    board[x][y] = piece;\n    // Check move doesn't allow king to be attacked\n    const sqrsCovered = this.opposingSquaresCovered(board, piece.type);\n    for (let move of sqrsCovered) {\n      if (arrayEquals(move, kingPos)) {\n        board[x][y] = endPiece;\n        board[a][b] = piece;\n        return true;\n      }\n    }\n    board[x][y] = endPiece;\n    board[a][b] = piece;\n    return false;\n  } \n  draw (board, piece, kingOppPos, castleCheck, lastEnPassant) {\n    for (let r = 0; r < 8; r++) {\n      for (let c = 0; c < 8; c++) {\n        const oppPiece = board[r][c];\n        const cIdx = piece.type? 0 : 1;\n        if (oppPiece instanceof Piece && oppPiece.type !== piece.type) {\n          const lMoves = oppPiece.allowedMoves(board, [r, c], oppPiece, kingOppPos, castleCheck[cIdx], lastEnPassant);\n          if (lMoves.length > 0) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  move(board, startPos, endPos, piece, kingPos, putInCheck, castleCheck, lastEnPassant, draw) {\n    const [a, b] = startPos;\n    let [x, y] = endPos;\n    let inCheck = false;\n    let checkmate = false;\n    let enPassantSet = false;\n    const kIdx = piece.type? 0 : 1;\n    const kOppIdx = kIdx? 0: 1;\n    const cIdx = piece.type? 0 : 1;\n    // return [board, kingPos, inCheck, checkmate, castleCheck, lastEnPassant, draw]\n    const retBoard = {\n      board: board,\n      lastSelectedPiecePos: false,\n      kingPos: kingPos,\n      inCheck: inCheck,\n      checkmate: checkmate,\n      castleCheck: castleCheck,\n      lastEnPassant: lastEnPassant,\n      draw: draw\n    }\n    const legalMoves = piece.allowedMoves(board, startPos, piece, kingPos[kIdx], castleCheck[cIdx], retBoard.lastEnPassant);\n    if (this.isLegalMove(legalMoves, endPos)) {\n      // If moving piece is king adjust kingPos and castle rights set to false\n      if (piece instanceof King) {\n        const kColDiff = y - b;\n        const rIdx = piece.type? 0: 7;\n        // Right Castles\n        if (!putInCheck && kColDiff === 2) {\n          kingPos[kIdx] = endPos;\n          board[rIdx][5] = board[rIdx][7];\n          board[rIdx][7] = \"-\";\n        }\n        // Left Castles\n        else if(!putInCheck && (kColDiff === -2 || kColDiff === -3)) {\n          kingPos[kIdx] = [rIdx, 2];\n          y = 2;\n          board[rIdx][3] = board[rIdx][0];\n          board[rIdx][0] = \"-\";\n        } \n        // Move King without castling\n        else {\n          kingPos[kIdx] = endPos;\n          castleCheck[cIdx][1] = false;\n        }\n      }\n      else if (piece instanceof Rook) {\n        if (a === 0) castleCheck[cIdx][0] = false;\n        else if (a === 7) castleCheck[cIdx][2] = false;\n      }\n      else if (piece instanceof Pawn) {\n        // Set the lastEnPassant \n        if ((a === 1 && x === 3) || (a === 6 && x === 4)) {\n          const backOne = piece.type? -1 : 1;\n          retBoard.lastEnPassant = [x + backOne, y];\n          enPassantSet = true;\n        }\n        // If lastEnPassant move occurs do it\n        if (arrayEquals(endPos, retBoard.lastEnPassant)){\n          const er = piece.type? x - 1 : x + 1;\n          board[er][y] = \"-\";\n        }\n        // If pawn reaches end of board promote pawn and trigger piece selector\n        if (x === 7 || x === 0) {\n          retBoard.promotePawn = endPos;\n          retBoard.lastSelectedPiecePos = startPos;\n          console.log(retBoard.promotePawn);\n        }\n        \n      }\n      if (!enPassantSet) retBoard.lastEnPassant = false;\n      board[a][b] = \"-\";\n      board[x][y] = piece;\n      // Sets check in state if put opponent in check\n      const inCheck = this.checkedOpponent(board, piece.type, kingPos[kOppIdx]);\n      // Returns checkmate if opponent in check and can't get out of check\n      if (inCheck && this.isCheckmate(board, piece, kingPos[kOppIdx])) {\n        retBoard.inCheck = true;\n        retBoard.checkmate = true;\n        return retBoard;\n      }\n      const[kr, kc] = kingPos[kOppIdx];\n      const oppKing = board[kr][kc];\n      // Returns draw if other player has no moves they can make\n      if (oppKing.allowedMoves(board, [kr, kc], oppKing, kingPos[kOppIdx], castleCheck[cIdx]).length === 0) {\n        if (this.draw(board, piece, kingPos[kOppIdx], castleCheck, lastEnPassant)) {\n          retBoard.draw = true;\n          return retBoard;\n        }\n      }\n      retBoard.inCheck = inCheck;\n      // retBoard.kingPos = kingPos;\n      // retBoard.lastEnPassant = lastEnPassant;\n      return retBoard;\n    }\n    retBoard.board = false;\n    return retBoard;\n  }\n}\n\nexport default ChessGame;","/Users/benjamincritoph/Programming/React/chess/Client/src/Chat.js",[],[],"/Users/benjamincritoph/Programming/React/chess/Client/src/connections/socket.js",[],[],"/Users/benjamincritoph/Programming/React/chess/Client/src/Game.js",[],[],"/Users/benjamincritoph/Programming/React/chess/Client/src/gameRoom/CreateGame.js",["94"],[],"/Users/benjamincritoph/Programming/React/chess/Client/src/gameRoom/JoinGameRoom.js",[],[],{"ruleId":"95","severity":1,"message":"96","line":2,"column":8,"nodeType":"97","messageId":"98","endLine":2,"endColumn":12},{"ruleId":"95","severity":1,"message":"99","line":19,"column":10,"nodeType":"97","messageId":"98","endLine":19,"endColumn":18},{"ruleId":"95","severity":1,"message":"100","line":19,"column":20,"nodeType":"97","messageId":"98","endLine":19,"endColumn":31},{"ruleId":"95","severity":1,"message":"101","line":6,"column":16,"nodeType":"97","messageId":"98","endLine":6,"endColumn":22},{"ruleId":"95","severity":1,"message":"102","line":8,"column":7,"nodeType":"97","messageId":"98","endLine":8,"endColumn":13},{"ruleId":"95","severity":1,"message":"103","line":13,"column":7,"nodeType":"97","messageId":"98","endLine":13,"endColumn":19},{"ruleId":"95","severity":1,"message":"104","line":90,"column":99,"nodeType":"97","messageId":"98","endLine":90,"endColumn":110},{"ruleId":"105","severity":1,"message":"106","line":132,"column":9,"nodeType":"107","messageId":"108","endLine":132,"endColumn":23,"suggestions":"109"},{"ruleId":"95","severity":1,"message":"110","line":148,"column":15,"nodeType":"97","messageId":"98","endLine":148,"endColumn":16},{"ruleId":"95","severity":1,"message":"111","line":206,"column":9,"nodeType":"97","messageId":"98","endLine":206,"endColumn":19},{"ruleId":"95","severity":1,"message":"112","line":232,"column":12,"nodeType":"97","messageId":"98","endLine":232,"endColumn":14},{"ruleId":"95","severity":1,"message":"113","line":232,"column":16,"nodeType":"97","messageId":"98","endLine":232,"endColumn":18},{"ruleId":"95","severity":1,"message":"114","line":55,"column":44,"nodeType":"97","messageId":"98","endLine":55,"endColumn":48},{"ruleId":"115","severity":1,"message":"116","line":67,"column":17,"nodeType":"117","endLine":67,"endColumn":121},{"ruleId":"115","severity":1,"message":"116","line":74,"column":13,"nodeType":"117","endLine":74,"endColumn":84},{"ruleId":"95","severity":1,"message":"118","line":2,"column":7,"nodeType":"97","messageId":"98","endLine":2,"endColumn":12},{"ruleId":"119","severity":1,"message":"120","line":141,"column":3,"nodeType":"121","messageId":"122","endLine":143,"endColumn":4},{"ruleId":"95","severity":1,"message":"123","line":162,"column":7,"nodeType":"97","messageId":"98","endLine":162,"endColumn":12},{"ruleId":"119","severity":1,"message":"120","line":195,"column":3,"nodeType":"121","messageId":"122","endLine":197,"endColumn":4},{"ruleId":"119","severity":1,"message":"120","line":214,"column":3,"nodeType":"121","messageId":"122","endLine":216,"endColumn":4},{"ruleId":"119","severity":1,"message":"120","line":233,"column":3,"nodeType":"121","messageId":"122","endLine":235,"endColumn":4},{"ruleId":"119","severity":1,"message":"120","line":256,"column":3,"nodeType":"121","messageId":"122","endLine":258,"endColumn":4},{"ruleId":"119","severity":1,"message":"120","line":283,"column":3,"nodeType":"121","messageId":"122","endLine":285,"endColumn":4},{"ruleId":"95","severity":1,"message":"124","line":1,"column":9,"nodeType":"97","messageId":"98","endLine":1,"endColumn":14},{"ruleId":"95","severity":1,"message":"118","line":4,"column":7,"nodeType":"97","messageId":"98","endLine":4,"endColumn":12},{"ruleId":"125","severity":1,"message":"126","line":61,"column":38,"nodeType":"127","messageId":"128","endLine":61,"endColumn":69},{"ruleId":"129","severity":1,"message":"130","line":43,"column":15,"nodeType":"117","endLine":43,"endColumn":18},"no-unused-vars","'Game' is defined but never used.","Identifier","unusedVar","'username' is assigned a value but never used.","'setUsername' is assigned a value but never used.","'Howler' is defined but never used.","'socket' is assigned a value but never used.","'soundEffects' is assigned a value but never used.","'promotePawn' is assigned a value but never used.","no-unsafe-negation","Unexpected negating the left operand of 'instanceof' operator.","BinaryExpression","unexpected",["131","132"],"'c' is assigned a value but never used.","'winMessage' is assigned a value but never used.","'pr' is assigned a value but never used.","'pc' is assigned a value but never used.","'turn' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'BLACK' is assigned a value but never used.","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","'ecOff' is assigned a value but never used.","'Piece' is defined but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'kingOppPos'.","ArrowFunctionExpression","unsafeRefs","jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/HEAD/docs/rules/anchor-is-valid.md",{"messageId":"133","data":"134","fix":"135","desc":"136"},{"messageId":"137","fix":"138","desc":"139"},"suggestNegatedExpression",{"operator":"140"},{"range":"141","text":"142"},"Negate 'instanceof' expression instead of its left operand. This changes the current behavior.","suggestParenthesisedNegation",{"range":"143","text":"144"},"Wrap negation in '()' to make the intention explicit. This preserves the current behavior.","instanceof",[4631,4661],"(selectedPiece instanceof Piece)",[4630,4644],"(!selectedPiece)"]